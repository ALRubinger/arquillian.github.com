---
layout: guide
title: Getting Started
---
-# TODO:
-# JBoss Nexus Repository
#content
  :textile
    <div class="header">
    h2. Getting Started

    This guide introduces you to Arquillian. After reading this guide, you'll be able to:

    * Add the Arquillian infrastructure to a Maven-based Java project
    * Write an Arquillian test case to assert the behavior of a CDI(Contexts and Dependency Injection) bean
    * Execute the Arquillian test case on multiple compatible containers

    You'll learn all of these skills by incorporating Arquillian into the test suite of a Java EE application built using Maven. We've designed this guide to be a fast read to get you started quickly!
    </div>

    h3(#assumptions). Assumptions

    The easiest way to get started with Arquillian is to incorporate it into the test suite of a project build that offers dependency management. Today, the most well-known build tool in this category is "Maven":http://maven.apache.org. This guide will navigate you to your first green bar using a sample Maven project.

    p(info). %Arquillian does not depend on Maven, or any other build tool for that matter. It works just as well--if not better--when used in a project with an Ant or Gradle build. Ideally, the build tool should offer dependency management as it simplifies the task of setting up the Arquillian libraries since they are distributed in the "JBoss (Nexus) software repository":http://community.jboss.org/wiki/MavenRepository.%

    This guide assumes you have Maven available, either in your command shell or your IDE. If you don't, please "install it now":http://maven.apache.org/download.html.

    h3(#create_new_project). Create a New Project

    First, create a Maven-based Java project using the command below. _Copy the text after the @$@ and paste it into your command shell._

    bc(command).. $ mvn archetype:generate -DarchetypeGroupId=net.avh4.mvn.archetype \
    -DarchetypeArtifactId=java-1.6-archetype

    p. Respond to the prompts by entering the value shown after each double colon below. Press the Enter key after each line (as indicated by @<ENTER>@).

    bc.. Define value for property 'groupId': : org.arquillian.example <ENTER>
    Define value for property 'artifactId': : arquillian-tutorial <ENTER>
    Define value for property 'version': : <ENTER>
    Define value for property 'package': : <ENTER>
    Confirm properties configuration:
    groupId: org.arquillian.example
    artifactId: arquillian-tutorial
    version: 1.0-SNAPSHOT
    package: org.arquillian.example
    Y: : <ENTER>

    p. This command generated a Maven-based Java project inside a new folder named @arquillian-tutorial@ under the current directory. The file structure of the project is shown below:

    * src/
    ** main/
    *** java/ - Place all application Java source files here (under Java package)
    *** resources/ - Place all application configuration files here
    * src/
    ** test/
    *** java/ - Place all test Java source files heres (under Java package)
    *** resources/ - Place all test configuration files here (e.g., arquillian.xml)
    * pom.xml - The Maven build file. Tells Maven how your project should be built.

    p(info). %The project is pre-configured to use Java 6 and JUnit 4.8, the minimum required versions of Java and JUnit for using Arquillian, respectively.%

    The generator also created a Java package named @org.arquillian.example@ underneath the two @java@ folders. You should put your Java source files in this package rather than at the root of the @java@ folder.

    p(warning). %Arquillian also supports TestNG 5. However, we'll be using JUnit throughout this guide.%

    Go ahead and open up the @pom.xml@ in your editor. You should see an XML file containing basic project information, a build section and a dependencies section. You can remove all the @<dependency>@ elements below the JUnit dependency as they aren't required.
    
    After making the change, you should end up with the contents below (trimmed for brevity):

    div(filename). pom.xml

    bc(prettify).. <project xmlns="http://maven.apache.org/POM/4.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
            http://maven.apache.org/POM/4.0.0
            http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <groupId>org.arquillian.example</groupId>
        <artifactId>arquillian-tutorial</artifactId>
        <version>1.0-SNAPSHOT</version>
        <packaging>jar</packaging>
        <name>arquillian-tutorial</name>
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>2.3.2</version>
                    <configuration>
                        <source>1.6</source>
                        <target>1.6</target>
                    </configuration>
                </plugin>
            </plugins>
        </build>
        <dependencies>
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>4.8.1</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </project>

    p. We're going to be writing Java EE 6 components. So we also need to add the Java EE 6 API to the classpath so we can compile them.
    
    Open up the @pom.xml@ file once again and add the following XML fragment directly inside the @<dependencies>@ element. Here's how the dependencies section should look once your done:

    bc(prettify).. <dependencies>
        <dependency>
            <groupId>org.jboss.spec</groupId>
            <artifactId>jboss-javaee-web-6.0</artifactId>
            <version>2.0.0.Final</version>
            <type>pom</type>
            <scope>provided</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.apache.xalan</groupId>
                    <artifactId>xalan</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.8.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    p. You also need to add the JBoss (Nexus) repository, where the Java EE API and Arquillian-related artifacts are hosted. Insert the following XML fragment directly above the @<build>@ element in the @pom.xml@ to add this repository to your build.

    bc(prettify).. <repositories>
        <repository>
            <id>jboss-public-repository</id>
            <name>JBoss Public Repository</name>
            <url>http://repository.jboss.org/nexus/content/groups/public</url>
        </repository>
    </repositories>

    p. The foundation of your project is now ready! Let's open the project in Eclipse so we can start writing some code.

    h3(#open_project_in_eclipse). Open Project in Eclipse

    When developing a Java project, you'll likely use an IDE, such as Eclipse. That's why Arquillian has been designed to be IDE friendly, meaning you can run Arquillian tests from the IDE without making unconventional changes. So let's start taking advantage of the IDE immediately.

    To open the project in Eclipse, begin by launching Eclipse. Since this is a Maven project, you'll need the "Maven Integration for Eclipse":http://eclipse.org/m2e (m2e) plugin. If you don't already have it installed, follow these simple steps:

    # Select @Help > Eclipse Marketplace...@ from the main menu
    # Type "maven" in the Find input field (no quotes) and press Enter
    # Click the Install button next to Maven Integration for Eclipse
    # Complete the install wizard, then restart Eclipse if prompted

    Once you have the Maven Integration plugin installed, follow these steps to open the project:

    # Select @File > Import...@ from the main menu
    # Type "existing maven" in the input source field
    # Select the option Existing Maven Projects, then click the Next button
    # Click the Browse... button
    # Navigate the project folder on your filesystem, then click the OK button
    # Click the Finish button to open the project

    Eclipse will recognize the Maven project and open it in the Project Navigator view. If you expand the project, it look similar to this image:

    !/images/guides/arquillian_tutorial_eclipse_project.png!

    Now we can really get down to business!

    h3(#create_component). Create a Component

    In order to write an Arquillian test, we need to have a component for it to test. Let's begin by creating a basic component so that you can learn how to execute an Arquillian test without other distractions. We'll gradually move to more complex scenarios.

    In your IDE, create a new Java class named @Greeter@ in the @org.arquillian.example@ package. Replace the contents of the file with this greeter logic:

    div(filename). src/main/java/org/arquillian/example/Greeter.java

    bc(prettify).. package org.arquillian.example;

    import java.io.PrintStream;
    
    /**
     * A component for creating personal greetings.
     */
    public class Greeter {
        public void greet(PrintStream to, String name) {
            to.println(createGreeting(name));
        }
        
        public String createGreeting(String name) {
            return "Hello, " + name + "!";
        }
    } 

    p. We want to verify that this class behaves properly when invoked as a CDI(Contexts and Dependency Injection) bean. Of course, we could simply write a unit test. But let's pretend that the bean uses enterprise services such as dependency injection and messaging and must be used inside a container. (Besides, that way we give it room to grow !/images/emoticon_wink.png!)
    
    To use the class as a CDI bean, we'll be injecting it into the test using the @@Inject@ annotation. That calls for an Arquillian test! That means it's time to add the Arquillian API to the project!

    h3(#add_arquillian_apis). Add the Arquillian APIs

    Once again open up the @pom.xml@ file, located in the root folder of the project, in your editor. Append the following XML fragment directly under the last @<dependency>@ element:

    bc(prettify).. <dependency>
        <groupId>org.jboss.arquillian.junit</groupId>
        <artifactId>arquillian-junit-container</artifactId>
        <version>1.0.0.CR5</version>
        <scope>test</scope>
    </dependency>

    p. This dependency adds the Arquillian JUnit integration, as well as the Arquillian and ShrinkWrap APIs, to the test classpath. You need these libraries to write and compile a JUnit Arquillian test.

    p(info). %If you wanted to use TestNG instead of JUnit, you would substitute this dependency with the equivalent Arquillian TestNG integration.%

    You're all set to write your first Arquillian test!

    h3(#write_arquillian_test). Write an Arquillian Test

    An Arquillian test looks just like a unit test, just with some extra flair.

    Begin by creating a new JUnit test case in the @org.arquillian.example@ package and name it @GreeterTest@. You won't need the typical setup and teardown methods since Arquillian is doing most of the heavy lifting. Here's what we have so far:

    div(filename). src/test/java/org/arquillian/example/GreeterTest.java

    bc(prettify).. package org.arquillian.example;

    import static org.junit.Assert.*;
    import org.junit.Test;
    
    public class GreeterTest {
        @Test
        public void test() {
            fail("Not yet implemented");
        }
    } 

    p. Now, about that flair. An Arquillian test case must have three things:

    # A @@RunWith(Arquillian.class)@ annotation on the class
    # A static method annotated with @@Deployment@ that returns a ShrinkWrap archive
    # At least one method annotated with @@Test@

    The @@RunWith@ annotation tells JUnit to use Arquillian as the test controller. Arquillian then looks for a static method annotated with the @@Deployment@ annotation to retrieve the test archive (i.e., microdeployment). Then some magic happens, and each @@Test@ method is run inside the container environment.
    
    h4. What's a test archive? 

    The purpose of the test archive is to isolate the classes and resources which are needed by the test from the remainder of the classpath.Unlike a normal unit test, Arquillian does not simply dip into the entire classpath. Instead, you include only what the test needs (which may be the entire classpath, if that's what you decide). The archive is defined using "ShrinkWrap":http://jboss.org/shrinkwrap, which is a Java API for creating archives (e.g., jar, war, ear) in Java. The microdeployment strategy let's you focus on precisely the classes you want to test and, as a result, the test remains very lean.

    p(info). %ShrinkWrap also supports resolving artifacts (libraries) and create configuration files programmatically, which can then be added to the test archive.%

    Let's add that Arquillian flair to the test: 

    div(filename). src/test/java/org/arquillian/example/GreeterTest.java

    bc(prettify).. package org.arquillian.example;

    import org.jboss.arquillian.container.test.api.Deployment;
    import org.jboss.arquillian.junit.Arquillian;
    import org.jboss.shrinkwrap.api.ShrinkWrap;
    import org.jboss.shrinkwrap.api.asset.EmptyAsset;
    import org.jboss.shrinkwrap.api.spec.JavaArchive;
    import org.junit.Test;
    import org.junit.runner.RunWith;

    @RunWith(Arquillian.class)
    public class GreeterTest {

        @Deployment
        public static JavaArchive createDeployment() {
            return ShrinkWrap.create(JavaArchive.class)
                .addClass(Greeter.class)
                .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");
        }

        @Test
        public void test() {
            fail("Not yet implemented");
        }
    } 
    
    p. Using ShrinkWrap, we've defined a Java archive (jar) as the deployment that includes the @Greeter@ class that the test will invoke and an empty beans.xml in the META-INF directory to activate CDI in this archive.

    Now all we need to do is inject the @Greeter@ instance into a field directly above the test method and replace the unimplemented test method with one that asserts the behavior of the bean. To give you that warm fuzzy feeling, we'll also print the greeting to the console.

    bc(prettify).. @Inject
    Greeter greeter;
    
    @Test
    public void should_create_greeting() {
        assertEquals("Hello, Earthling!", greeter.createGreeting("Earthling"));
        greeter.greet(System.out, "Earthling");
    }

    p. You've written your first Arquillian test! Ah, but you're probably wondering how to run it !/images/emoticon_confused.png! If you're thinking, "Just like a unit test" you're correct! However, we first need to add a container adapter to the classpath.

    h3(#add_container_adapter). Add Container Adapter 

    p. foo

#sidebar
  %h3.chapter_header Chapters
  %ol.chapters
    %li
      %a{ :href=>'#assumptions' } Assumptions
    %li
      %a{ :href=>'#create_new_project' } Create a New Project
    %li
      %a{ :href=>'#open_project_in_eclipse' } Open Project in Eclipse
    %li
      %a{ :href=>'#create_component' } Create a Component
    %li
      %a{ :href=>'#add_arquillian_apis' } Add Arquillian APIs
    %li
      %a{ :href=>'#write_arquillian_test' } Write an Arquillian Test
    %li
      %a{ :href=>'#add_container_adapter' } Add Container Adapter
